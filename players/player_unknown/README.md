# 序
题目出的有点复杂，Orz 果然写 wp 的时候就遭到报应了。

盯着一片空白的编辑器，根本不知道怎么写官方题解..。而且这份题解还是给萌新看的，更不知道从什么地方下手了..。

其实这些题目本来都只有最后一问的，为了照顾萌新的游戏体验，就都加上了一道简单的子题目，所以剧情上有不连贯的地方还请见谅。

emmmm，已经混了这么多字数了，是时候开始 wp 了。我给每道子题都留写了 TL;DR 小节，建议没做出来的同学对照这一节试着抢救一下。如果还是决定弃疗，再来看后面的详解也不迟。
# 秘籍残篇
### 滑稽 Art
##### TL;DR
质因数分解，添加换行符，缩小字体
##### 详解
Malbolge 语言是会忽略空格的，可是为什么 txt 里面有这么多空格呢?

用文本编辑器打开发现，这些字符好像有些规律。调小字体大小后发现有明显的 pattern。

用浏览器打开(firefox 和 chrome 都行，黑曜石也行)，调到合适的字体大小，再手动调整宽度，可以看到一个畸变的图案，不过不影响做题，仍然可以读出 flxg。很多人提交记录里面把大写 U 看成小写，估计都是用这种方法做的。

当然官方解法肯定不是这么做的。

使用 wc 命令统计一下字符数，发现一共有 154012 个字节。我们应该可以猜到这个文件是个字符画，但是换行被去掉了所以变得很难看。使用 factor 或者 yafu 对这个数进行质因数分解，发现 154012 = 2 * 2 * 139 * 277。经验上，等宽字体字符画像素上的长宽比和字符数的长宽比大致在 1 : 2 左右。所以我们猜测，这个字符画的长宽大概是 556 * 277 或者 574 * 278。

使用 python 或其他语言，每隔这么多字符打印一次 '\n'，在控制台上能看到非常正宗的滑稽图案。flxg 赫然醒目。
### 天书易解
##### TL;DR
https://www.matthias-ernst.eu/malbolgereverse.html
##### 详解
其实这道题主要考察选手 Google 能力..。

从出题人的角度，如果要出一道 Malbolge 逆向，出题人会怎么写代码。

其实这道题的关键就在于弄清楚条件判断是如何实现的。Malbolge 语言没有条件跳转语句，所以只能通过跳转表模拟。弄清楚这一点的话剩下的就是时间问题了。

所以通过搜索，能找到 Cat halts on EOF 这个程序的源码。甚至可以找到 https://github.com/zb3/malbolge-tools/blob/master/samples/src/q.hell。

通过 HELL IDE 反汇编，可以看到这份代码与本题之间的相似程度非常之高。实际上，许多 Malbolge 程序处理 if 判断的方法基本都是同一份代码。

确定本题是由 HELL IDE 编译的又一方法是观察代码的前几个字节。HELL IDE 在编译的时候会增加一些初始化的代码，相当于给内存分成代码区和数据区。仔细与其他程序比较可以看到明显的共同点。

另一种预期做法，污点分析。

可以注意到键盘的输入会相互 ROT 和 CRZ，最终形成一个 Ternary byte，之后的处理就全部基于这个字节上进行，输入数据的其他信息都丢失。所以可以对这个字节进行爆破，自己写好调试器之后十分简单。

(此处省略爆破代码)

做出来题目的同学并不期望能拿到 Key，因为这是一个多对一的压缩过程。这里给一个可行的 Key: ./;'[]-=0
本题 HELL 源代码见 flxg.hell 文件。
# FLXG 的秘密
### 来自未来的漂流瓶
##### TL;DR
六十四卦那些卦象，你们看着不觉得就像二进制吗..。
##### 详解
下下来直接打开发现乱码。不知道为啥编辑器不觉得这是 UTF-8。切换到 UTF-8 的编码，发现果然一堆六十四卦的名词。

无论怎么编码的，第一步肯定是把不同卦分离开来。六十四卦的名称比较杂乱，是变长的 CISC 架构，代码里面的六十四卦卦名要老老实实写出来。

接下来就是脑洞时间了。六十四卦每一卦都有 6 个 bits 的信息，而一般的数据都是以 8 个 bits 为单位。因此，我们看一下长度，发现可以被 8 整除，这进一步验证了我们的猜想。接下来，就是考虑如何把一个卦象转化为 6 个 bits。

有三类显而易见的情况:
* 每个卦象自下而上，阴阳对应 0 和 1，这就是两种可能
* 每个卦象自上而下，阴阳对应 0 和 1，这又是两种可能
* 卦象以先天六十四卦顺序，也是 Unicode 字符集中的顺序编码

写出来脚本跑一跑，发现第二种情况能产生一个 gzip 的文件。解压时提示文件损坏，查看文件末尾即可得到 flxg。
### 难以参悟的秘密
##### TL;DR
Merkle Hellman Knapsack Cryptosystem
##### 详解
本题是一道逆向。

解压得到一个可执行文件和一堆动态链接库。拖进 IDA 里发现，程序会读取 passkey.txt 的内容，然后通过调用动态链接库的函数进行校验。最后经过一番处理，每 8 行变成一个大整数。然后根据一个 128bit 的数的某一位进行求和。最后判断是否结果等于最后一个大整数。这实际上是一个 Merkle Hellman Knapsack Cryptosystem。

二进制里重要函数都已经标注出来。一旦我们弄清楚程序的意图，就可以继续做下去了。思路非常清晰: 先要恢复 passkey.txt 的内容，进而得到每个大整数。然后求解 flxg。

第一步，需要选手批量处理动态链接库中的代码。动态链接库里面的验证基本可以总结为 kx+b=x，通过将 k 和 b 提取出来，可以求解 x。而 k 和 b 两个数字在 lock 函数中偏移固定，可以通过能处理 ELF 的 python 库或二进制分析框架提取出来。

第二步，我们得到了 passkey.txt 应有的内容。现在我们需要还原 128 个大整数。大致有两种思路，一种是动态运行程序，通过修改程序的代码或者 Hook 或者 DBI 或者调试器脚本的方法，可以得到这些大整数。另一种是通过逆向，自己重现相应的算法。这道题里面使用了一个不常见的 Hash 算法 -- JH，很难识别出来。并且代码中大量使用 SSE，很难手动实现。但是可以通过将可执行文件转为动态链接库的方法导出相关函数，从而直接运行程序的算法。

第三步，Low Density attack。这实际上是 1984 年的攻击了。需要找到论文简单复现一下即可。比如 http://www4.ncsu.edu/~smsulli2/MA437_Fall2017/knapsack.pdf。其核心思想是构造出一个 Lattice，这些向量加起来和为 0。然后就变成了格点规约问题了。通过 LLL 算法很容易求出解。

(此处省略丑陋的 Mathematica 代码)

本题代码见 flxg.c 与 lock.c。代码实际上不能直接编译，因为缺少 jh.h (只是一个 hash 算法的实现) 和 lock.h (由脚本生成)。不过大致流程比较清晰。可参看。
# CWK 的试炼
### 神庙设计图，Get!
##### TL;DR
Tor，nc with proxy，LSB，抠图
##### 详解
得到一张webp格式的图片。使用官方工具分析得知此 webp 图片为无损压缩。使用 dwebp 转换为 png 格式。注意，如果有选手使用第三方工具转换而导致后续步骤无法进行，请不要抱怨题目有非预期的错误，相反，您应该给这些第三方工具提 issue。

得到 png 后，使用 stegsolve 查看通道。发现绿色通道的 LSB 有明显的隐写痕迹。右下角有一个洋葱地址，中间的神庙区域有明显规律性条纹。实际上这个条纹是因为出题人故意使用 Base64 编码一遍，使得原来二进制中的规律部分更为明显。

我不知道为什么很多人都把这个地址和端口号当作 HTTP 协议。没有任何说明的情况下，一个端口并不应该默认为使用 HTTP 协议。这又不是 80 或者 8080 端口..。正确做法应该是使用 nc 连上去，会发现这实际上是一个类似于 pwnable 的一个交互方式。

至于如何使用洋葱，这里不再详述，请参考官网教程。一般的洋葱客户端会提供一个 9150 或者 9050 端口的 SOCKS 5 代理服务。使用 nc 的参数或者 proxychains-ng 均可接入。

连入后发现提示输入 CRC32。如果输入 webp 图片的 CRC32 会进一步提示设计图纸被藏在图片里。

所以我们转向绿色通道中的神庙区域。思路应该比较明显，需要把这片区域的像素抠出来。

为降低难度，这片区域已经用纯黑色的边框包围，并且保证了区域内没有纯黑色的像素点。一个最简单的做法是，使用 Photoshop 手动选择一小部分，选区 -> 扩大选区，可以将这片区域内的像素点全部选中。查看一下统计信息，可以发现这片区域内有 249024 个像素点。很明显可以被 8 整除。这是一个正面的提示。然后将这片区域粘贴到一个新的全黑色的背景图片上。保存。然后就可以写 python 脚本处理绿色通道的 LSB 了。

(此处省略处理脚本)

脚本得到的是一个 Base64 的字符串。解码后是一个 ELF 文件。在远程输入 Base64 字符串或者 ELF 的 CRC32 均可得到第一个 flxg。
### 此小技耳
##### TL;DR
https://gist.github.com/pzread/2ae0bb3aa5fe0dc69fcf3257c41db944，bit flipping attack
##### 详解
这道题其实是出题人学习去年 HTICON 里一个技巧的成果 (话说马上又要 HITCON 了)。有两个人做出来有点出人意料(可能有非预期了)，不过因为控制好了 SECCOMP，再怎么非预期也不会造成预期之外的危害 23333333

这道题功能很简单。首先输入用户名，判断不能为 root，拼接上 hash 后再使用随机的密钥和 IV 做 AES CBC 加密。另一个函数需要输入结果，然后通过密钥和 IV 解密，再比对 hash 正确性。之后判断用户名是否为 root，如果是 root 就直接给 flag。

这题有几个漏洞:

* 首先有整数溢出，溢出的后果是 double free。控制 free 的整数只有 8 位，所以 free 被拒绝 128 次后就可以随便 free 了。
* 其次内存拷贝用的是 strcpy，这个会造成越界。
* 然后就是密码学上的，bit flipping attack。通过更改 IV 可以更改解密后第一个分组的内容。
* 最后就是 HITCON 的奇技*巧，二进制中的 memcmp 实际上是 strcmp。

double free 不是用来利用的。实际上要注意到 init 里面会调用 mallopt，设置了这个函数会将 free 的 buffer 填充为 0xAA。而这次 malloc 的 buffer 很小，使用了 tcache 后所以需要 free 七次才行。

然后通过 strcpy，将 0xAA 复制到目标数组。通过 bit flipping attack 得到 root 的用户名和第一个 0xAA。然后需要绕过 hash 检测。所以我们不停的尝试，直到 hash 以 0x00 开头。这样 strcmp 比较两个空字符串会直接返回 0。

exp 见 poc.py，代码见 trial.c

关于如何做到将 memcmp 偷天换日到 strcmp，可以看 HITCON 的那篇 gist。基本原理就是内核计算 PHDR 的偏移错误，所以可以放上两个 PHDR，真 PHDR 中的 PT_DYNAMIC 中 DT_SYMTAB 被修改了。所以 ld.so 解析函数的时候会使用后面的 DT_SYMTAB，而一般的反汇编工具会使用 ELF Spec 下的 DT_SYMTAB。

更详细一点的介绍在这里，http://h3ysatan.blogspot.com/2018/02/quick-notes-hitcon-ctf-2017-qual-elf.html。
